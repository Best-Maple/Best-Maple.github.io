<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Best Maple</title>
  <icon>https://www.gravatar.com/avatar/8078ed4e45be539c9a8d384112189b44</icon>
  <subtitle>人生短短几个秋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://best-maple.github.io/"/>
  <updated>2020-01-20T09:24:32.243Z</updated>
  <id>http://best-maple.github.io/</id>
  
  <author>
    <name>Best Maple</name>
    <email>bestmaple@vip.qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL-事务与存储过程</title>
    <link href="http://best-maple.github.io/2020/01/20/SQL-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://best-maple.github.io/2020/01/20/SQL-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-01-20T08:10:22.000Z</published>
    <updated>2020-01-20T09:24:32.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote><p>释义：指访问并可能更新数据库中各种数据项的一个程序执行单元，由多个SQL语句组成，必须作为一个整体执行并向系统提交，要么都执行，要么都不执行。</p></blockquote><blockquote><p>语法：开始事务：Begin Transaction（<code>可以简写为tran</code>）</p></blockquote><blockquote><p>事务开始后只有两种结果（提交）commit tran 和（回滚）rollback tran ，如果在事务开始后，不进行提交或回滚，会将当前操作的表锁定</p></blockquote><img alt="事务" style="zoom: 150%;" data-src="http://tvax4.sinaimg.cn/large/006Et0gvgy1gb34oiyitcj30ni0a275k.jpg" class="lazyload"><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">begin tran</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">declare @tran_error int --创建一个变量用于接收</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">set @tran_error &#x3D; 0 --初始值为0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">update table set field &#x3D; &#39;@parame&#39; where field &#x3D; &#39;@parame&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">set @tran_error &#x3D; @tran_error+@@ERROR --@@ERROR系统变量记录SQL语句执行出错时的错误代码 只能记录单条</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">update table set field &#x3D; &#39;@parame&#39; where field &#x3D; &#39;@parame&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">set @tran_error &#x3D; @tran_error+@@ERROR --进行累加后判断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">if @tran_error &#x3D; 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">begin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">commit tran  --如果变量为0，则表明SQL没有错误，开始提交事务</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">begin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">rollback transaction --SQL出错，回滚事务</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">end</span></pre></td></tr></table></figure><p><strong>典型问题：银行转账，用户A转账到用户B时，A扣钱，B加钱 ，只有当两个语句都执行完成，才算合理</strong></p><p><em>事务的一种简写，设置  xact_abort 为 on。系统默认OFF  当为ON时，事务发生错误会自动回滚，而为OFF时，系统只回滚出错的SQL语句</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">set xact_abort ON</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">begin tran</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">update ATM set U_Money &#x3D; U_Money-5000 where UID &#x3D; UserA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">update ATM set U_Money &#x3D; U_Money+5000 where UID &#x3D; UserB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">commit tran</span></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a href="https://docs.microsoft.com/zh-cn/previous-versions/sql/compact/sql-server-compact-3.5/ms172001(v=sql.100)?redirectedfrom=MSDN" target="_blank" rel="noopener"><strong>（隔离级别）MSDN官方文档：</strong></a></p><p><strong>锁定在用作事务控制机制时，可以解决并发问题。 虽然可以在任何时间运行多个事务，但锁定只允许所有事务独立运行，运行时相互完全隔离。 在隔离级别，事务可以接受不一致的数据。 提高隔离级别可以更有效地防止数据的不一致性，但缺点是降低并发处理能力。</strong></p><p><strong>在 SQL Server Compact 3.5 中，应用程序需要的隔离级别决定了 SQL Server Compact 3.5 所使用的锁定行为。</strong></p><p><strong>SQL Server Compact 3.5 支持下列隔离级别（从最低到最高）：</strong></p><ul><li><strong>已提交读（SQL Server Compact 3.5 默认设置）</strong></li><li><strong>可重复读</strong></li><li><strong>可串行读（事务之间相互完全隔离）</strong></li></ul><p><strong>随着隔离级别的提高，可以更有效地防止数据的不一致性。 但是，这将降低事务的并发处理能力，会影响多用户访问。</strong></p><img alt="sql锁" style="zoom:150%;" data-src="http://tva4.sinaimg.cn/large/006Et0gvgy1gb34pni249j30lo0d8dha.jpg" class="lazyload"><hr><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote><p>释义：存储过程是在数据库中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。</p></blockquote><blockquote><p>语法(无参)：</p><p>Create Procedure（<code>可以简写为proc</code>） Name  </p><p>as</p><p>select * from table</p><p>执行：</p><p>exec Name</p></blockquote><blockquote><p>删除存储过程：drop proc procName</p></blockquote><blockquote><p>命名时建议不要以sp开头，那是系统存储过程的命名</p></blockquote><ul><li>无参的存储过程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">if exists(select name from sys.objects where name &#x3D; &quot;proc_demo&quot;) --判断存储过程是否存在</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">drop proc proc_demo --如果存在则删除</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">create proc proc_demo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">as</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">select * from [table]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">exec proc_demo</span></pre></td></tr></table></figure><ul><li><p>带参的存储过程</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">if exists(select name from sys.objects where name &#x3D; &quot;proc_demo&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">drop proc proc_demo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">create proc proc_demo(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[@Parame1] [type(int,varchar,...)],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    [@Parame2] [type(int,varchar,...)],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">as</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">select * from [table] where [table].[field] &#x3D; [@Parame1] and [table].[field] &#x3D; [@Parame2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">exec proc_demo @parame1 , @parame2</span></pre></td></tr></table></figure></li></ul><p><em>普通的就不演示了，看一个带参的以及带返回值的经典例子，分页</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">if exists(select name from sys.objects where name &#x3D; &#39;Proc_Pagination&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">drop proc Proc_Pagination</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">go</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">create proc Proc_Pagination(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    @PageIndex int , --页面索引</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    @PageSize int ,  --页面大小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    @DataCount int output  --返回数据总数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">as</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">select * from (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">select row_number() over(order by id) as number,* from Student</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">) as t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">where t.number between ((@PageIndex-1)*@PageSize)+1 and @PageIndex*@PageSize</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">set @DataCount &#x3D; select count(*) from Student</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">--执行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">declare @Count int   --创建变量用于接收存储过程的返回值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">exec Proc_Pagination 5,10,@Count output select @Count as 数据总数  --第五页，每页十条，输出数据总数</span></pre></td></tr></table></figure><blockquote><p>比较浅显，不足之处，欢迎讨论</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;释义：指访问并可能更新数据库中各种数据项的一个程序执行单元，由多个SQL语句组成，必须作为一个整体执行并向系统提交
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://best-maple.github.io/categories/SQL/"/>
    
    
      <category term="SQL" scheme="http://best-maple.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL-子查询 and 派生表</title>
    <link href="http://best-maple.github.io/2020/01/12/SQL-%E5%AD%90%E6%9F%A5%E8%AF%A2%20and%20%E6%B4%BE%E7%94%9F%E8%A1%A8/"/>
    <id>http://best-maple.github.io/2020/01/12/SQL-%E5%AD%90%E6%9F%A5%E8%AF%A2%20and%20%E6%B4%BE%E7%94%9F%E8%A1%A8/</id>
    <published>2020-01-12T07:42:42.000Z</published>
    <updated>2020-01-13T09:10:39.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌套子查询，将查询的值作为外部查询语句的条件"><a href="#嵌套子查询，将查询的值作为外部查询语句的条件" class="headerlink" title="嵌套子查询，将查询的值作为外部查询语句的条件"></a><strong>嵌套子查询，将查询的值作为外部查询语句的条件</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select * from [Table-1] &#x2F;*查询表1*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">where [Table-1].[Filed(Name)] in &#x2F;*where条件 运算符示例为in*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">(  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">select Name from [Table-2] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    where [Table-2].[Filed(ID)] &lt; 50</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">order by [Table-1].[Field] &#x2F;*可选排序*&#x2F;</span></pre></td></tr></table></figure><p>示例：</p><p><strong>[Table] Movie <code>电影表</code></strong></p><table><thead><tr><th align="center">ID（数据ID）</th><th align="center">TypeId（类别ID【外键】）</th><th align="center">Name（电影名称）</th><th align="center">Director（导演）</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">我和我的祖国</td><td align="center">文牧野</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">我不是药神</td><td align="center">文牧野</td></tr><tr><td align="center">3</td><td align="center">2</td><td align="center">哪吒之魔童降世</td><td align="center">饺子</td></tr></tbody></table><p><strong>[Table] MovieType <code>电影类别表</code></strong></p><table><thead><tr><th align="center">ID(数据ID)</th><th align="center">TypeName(类别名称)</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">剧情</td></tr><tr><td align="center">2</td><td align="center">奇幻</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;* 查询电影表中，电影类别为剧情片的电影 *&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">select Name,Director from Movie</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">where TypeId &#x3D; (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">select Id from MovieType</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    where TypeName &#x3D; &#39;剧情&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure><p>结果：</p><table><thead><tr><th align="center">Name</th><th align="center">Director</th></tr></thead><tbody><tr><td align="center">我和我的祖国</td><td align="center">文牧野</td></tr><tr><td align="center">我不是药神</td><td align="center">文牧野</td></tr></tbody></table><hr><h2 id="连接子查询"><a href="#连接子查询" class="headerlink" title="连接子查询"></a><strong>连接子查询</strong></h2><p><em>外部查询首先获得一个记录，然后将记录传递给内部查询，内部查询将记录中的值查询完成之后，再将值传递给外部查询作为查询条件</em></p><p>示例：</p><p><strong>[Table] TB_Order <code>订单表</code></strong></p><table><thead><tr><th align="center">ID</th><th align="center">UserID</th><th align="center">OrderDate</th><th align="center">Address</th><th align="center">Consignee</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">ANATA</td><td align="center">2015-05-04 12:24:79</td><td align="center">xx省xx市</td><td align="center">赵立</td></tr><tr><td align="center">2</td><td align="center">AROUT</td><td align="center">2015-06-21 10:20:41</td><td align="center">xx省xx市</td><td align="center">燕子</td></tr><tr><td align="center">3</td><td align="center">ANATA</td><td align="center">2015-08-12 14:31:06</td><td align="center">xx省xx市</td><td align="center">立立</td></tr><tr><td align="center">4</td><td align="center">AROUT</td><td align="center">2015-09-10 11:20:67</td><td align="center">xx省xx市</td><td align="center">燕子</td></tr></tbody></table><p><strong>查询订单表中每个用户的最早下单日期</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select * from TB_Order T1  &#x2F;*1外部查询首先获得一个记录 T1*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">where OrderData &#x3D; (&#x2F;*3将内部的结果作为外部查询的查询条件*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">select min(OrderData) from TB_Order T2  &#x2F;*min()函数得到最小的日期*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    where T1.UserID &#x3D; T2.UserID  &#x2F;*2外部查询出来的T1与内部的T2进行查询*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">order by T1.UserID &#x2F;*排序*&#x2F;</span></pre></td></tr></table></figure><p>结果：</p><table><thead><tr><th align="center">ID</th><th align="center">UserID</th><th align="center">OrderData</th><th align="center">Address</th><th align="center">Consignee</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">ANATA</td><td align="center">2015-05-04 12:24:79</td><td align="center">xx省xx市</td><td align="center">赵立</td></tr><tr><td align="center">3</td><td align="center">AROUT</td><td align="center">2015-08-12 14:31:06</td><td align="center">xx省xx市</td><td align="center">燕子</td></tr></tbody></table><h2 id="ISNULL函数-处理null数据"><a href="#ISNULL函数-处理null数据" class="headerlink" title="ISNULL函数 处理null数据"></a>ISNULL函数 处理null数据</h2><p><code>select isnull(p1,p2)  /*如果p1为空 则显示p2 如果p1不为空 则显示p1*/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select isnull(null,&#39;不是空的&#39;)</span></pre></td></tr></table></figure><table><thead><tr><th align="center">未命名</th></tr></thead><tbody><tr><td align="center">不是空的</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select isnull(&#39;content&#39;,&#39;不是空的&#39;)</span></pre></td></tr></table></figure><table><thead><tr><th align="center">未命名</th></tr></thead><tbody><tr><td align="center">content</td></tr></tbody></table><h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p><strong>派生表它将子查询的结果做为一个表来进行处理，子查询的结果得出的新表就是“派生表”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">select * from ( select [Field] from [Table] where [condition] ) [TableName(T1)] &#x2F;*括号是必须的*&#x2F;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      嵌套子查询 - 连接子查询 - ISNULL()函数处理空数据 - 派生表 
    
    </summary>
    
    
      <category term="SQL" scheme="http://best-maple.github.io/categories/SQL/"/>
    
    
      <category term="SQL" scheme="http://best-maple.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis(2) - Redis字符串命令</title>
    <link href="http://best-maple.github.io/2020/01/06/Redis(2)%20-%20Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%BD%E4%BB%A4/"/>
    <id>http://best-maple.github.io/2020/01/06/Redis(2)%20-%20Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%BD%E4%BB%A4/</id>
    <published>2020-01-06T07:14:08.000Z</published>
    <updated>2020-01-06T08:57:08.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>string是redis中的基本数据类型，可以理解为以键值对的方式存储。</p><p>它的存储类型为二进制，可以存入任何数据</p><p>一个键最大可以存储512M的数据 ，一个汉字为2字节，大约可以存入2.5亿个汉字。</p></blockquote><h2 id="SET-设置指定键的值"><a href="#SET-设置指定键的值" class="headerlink" title="SET 设置指定键的值"></a>SET <code>设置指定键的值</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set username Kiven</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr></table></figure><h2 id="GET读取指定键的值"><a href="#GET读取指定键的值" class="headerlink" title="GET读取指定键的值"></a>GET<code>读取指定键的值</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get username</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&quot;Kiven&quot;</span></pre></td></tr></table></figure><h2 id="GETRANGE截取返回的字符串"><a href="#GETRANGE截取返回的字符串" class="headerlink" title="GETRANGE截取返回的字符串"></a>GETRANGE<code>截取返回的字符串</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; getrange username 0 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&quot;Kive&quot;</span></pre></td></tr></table></figure><h2 id="GETSET设置新的键值并返回之前的键值"><a href="#GETSET设置新的键值并返回之前的键值" class="headerlink" title="GETSET设置新的键值并返回之前的键值"></a>GETSET<code>设置新的键值并返回之前的键值</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; getset username Tom</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&quot;Kiven&quot;</span></pre></td></tr></table></figure><h2 id="MGET获取一个或多个键值"><a href="#MGET获取一个或多个键值" class="headerlink" title="MGET获取一个或多个键值"></a>MGET<code>获取一个或多个键值</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET key1 &quot;Kiven&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET key2 &quot;Tom&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MGET key1 key2 key3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">1) &quot;Kiven&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">2) &quot;Tom&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">3) (nil)</span></pre></td></tr></table></figure><h2 id="SETEX设置指定键的值并添加一个过期时间（秒）"><a href="#SETEX设置指定键的值并添加一个过期时间（秒）" class="headerlink" title="SETEX设置指定键的值并添加一个过期时间（秒）"></a>SETEX<code>设置指定键的值并添加一个过期时间（秒）</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setex outStr 15 redis</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ttl outStr</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get outStr</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&quot;redis&quot;</span></pre></td></tr></table></figure><blockquote><p>ttl key -&gt; 返回剩余时间</p></blockquote><blockquote><p>如果在执行setex之前，目标键值已存在，则会替换掉原键值</p></blockquote><h2 id="SETNX在指定键名不存在时，为键设置值"><a href="#SETNX在指定键名不存在时，为键设置值" class="headerlink" title="SETNX在指定键名不存在时，为键设置值"></a>SETNX<code>在指定键名不存在时，为键设置值</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; exists animal</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(integer) 0   #animal 不存在</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setnx animal Cat</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 1   #设置成功</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setnx animal Pig</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">(imteger) 0   #animal存在，设置失败</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get animal</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&quot;Cat&quot;</span></pre></td></tr></table></figure><h2 id="STRLEN返回键值的长度"><a href="#STRLEN返回键值的长度" class="headerlink" title="STRLEN返回键值的长度"></a>STRLEN<code>返回键值的长度</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set name kiven</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; strlen name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 5</span></pre></td></tr></table></figure><h2 id="MSET同时设置多个-Key-Value"><a href="#MSET同时设置多个-Key-Value" class="headerlink" title="MSET同时设置多个[Key,Value]"></a>MSET<code>同时设置多个[Key,Value]</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; mset firstname kiven lastname chen</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get firstname</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&quot;kiven&quot;</span></pre></td></tr></table></figure><h2 id="MSETNX同时设置多个-Key-Value-，且仅当Key不存在"><a href="#MSETNX同时设置多个-Key-Value-，且仅当Key不存在" class="headerlink" title="MSETNX同时设置多个[Key,Value]，且仅当Key不存在"></a>MSETNX<code>同时设置多个[Key,Value]，且仅当Key不存在</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; mset firstname kiven lastname chen</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; msetnx test 1 firstname 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 0   #test不存在但是firstname存在  设置失败</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; msetnx test 1 demo 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">OK            #都不存在时，可以设置成功</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; msetnx animal Cat animal Pig</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">OK            #当键名相同时，也可设置成功，但同一键名只取最后一次设置的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get animal</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&quot;Pig&quot;</span></pre></td></tr></table></figure><h2 id="PSETEX以毫秒为单位设置键的过期时间"><a href="#PSETEX以毫秒为单位设置键的过期时间" class="headerlink" title="PSETEX以毫秒为单位设置键的过期时间"></a>PSETEX<code>以毫秒为单位设置键的过期时间</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; psetex mykey 6000 &quot;redis&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; pttl mykey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 3896    #返回剩余毫秒数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get mykey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&quot;redis&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">#时间过期之后</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get mykey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">(nil)</span></pre></td></tr></table></figure><h2 id="INCR将redis存储的数字值增一，且键值需要为整数"><a href="#INCR将redis存储的数字值增一，且键值需要为整数" class="headerlink" title="INCR将redis存储的数字值增一，且键值需要为整数"></a>INCR<code>将redis存储的数字值增一，且键值需要为整数</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set scores 60</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incr scores</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 61</span></pre></td></tr></table></figure><blockquote><p>如果在非数字字符上使用INCR会报错</p><p>如果key不存在，incr会创建key并自增1</p></blockquote><h2 id="INCRBY将redis存储的数字值按指定的大小增加，且键值需要为整数"><a href="#INCRBY将redis存储的数字值按指定的大小增加，且键值需要为整数" class="headerlink" title="INCRBY将redis存储的数字值按指定的大小增加，且键值需要为整数"></a>INCRBY<code>将redis存储的数字值按指定的大小增加，且键值需要为整数</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set scores 60</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incrby scores 40</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 100</span></pre></td></tr></table></figure><blockquote><p>如果key不存在 ，incrby会创建该key，并增加指定大小的数字</p></blockquote><h2 id="INCRBYFLOAT将存储值加上指定的浮点数"><a href="#INCRBYFLOAT将存储值加上指定的浮点数" class="headerlink" title="INCRBYFLOAT将存储值加上指定的浮点数"></a>INCRBYFLOAT<code>将存储值加上指定的浮点数</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set scores 59</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incrbyfloat scores 0.5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&quot;59.5&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incrbyfloat scores 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&quot;61.5&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incrbyfloat scores 1.000000000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&quot;62.5&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incrbyfloat scores 0.5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&quot;63&quot;</span></pre></td></tr></table></figure><blockquote><p>incrbyfloat可以在浮点数或者整数上添加浮点数或整数</p></blockquote><h2 id="DECR将键值数值减一"><a href="#DECR将键值数值减一" class="headerlink" title="DECR将键值数值减一"></a>DECR<code>将键值数值减一</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set scores 60</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; decr scores</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 59</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set scores 0 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; decr scores   #当目标值为0 再减一 变为负数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">(integer) -1</span></pre></td></tr></table></figure><h2 id="DECRBY将数值减去指定的大小-指定大小需要为整数"><a href="#DECRBY将数值减去指定的大小-指定大小需要为整数" class="headerlink" title="DECRBY将数值减去指定的大小,指定大小需要为整数"></a>DECRBY<code>将数值减去指定的大小,指定大小需要为整数</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set scores 60</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; decrby scores 59</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 1</span></pre></td></tr></table></figure><h2 id="APPEND在字符串末尾添加指定的内容"><a href="#APPEND在字符串末尾添加指定的内容" class="headerlink" title="APPEND在字符串末尾添加指定的内容"></a>APPEND<code>在字符串末尾添加指定的内容</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; exists str</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(integer) 0 #不存在</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; append str &quot;hello&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(integer) 5 #生成键并添加指定内容并返回字符串长度</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; append str &quot; redis&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">(integer) 11</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; get str</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&quot;hello redis&quot;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;string是redis中的基本数据类型，可以理解为以键值对的方式存储。&lt;/p&gt;
&lt;p&gt;它的存储类型为二进制，可以存入任何数据&lt;/p&gt;
&lt;p&gt;一个键最大可以存储512M的数据 ，一个汉字为2字节，大约可以存入2.5亿个汉字。&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://best-maple.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://best-maple.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis（1）- Window(win10)上安装Redis</title>
    <link href="http://best-maple.github.io/2020/01/06/Redis(1)%20-%20Window(win10)%E4%B8%8A%E5%AE%89%E8%A3%85Redis/"/>
    <id>http://best-maple.github.io/2020/01/06/Redis(1)%20-%20Window(win10)%E4%B8%8A%E5%AE%89%E8%A3%85Redis/</id>
    <published>2020-01-06T02:29:32.000Z</published>
    <updated>2020-01-06T04:01:50.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Windows上的Redis在github上有一个开源项目，但是好像很久没有维护更新了，上一次是在2016年。</p><p><a href="https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.zip" target="_blank" rel="noopener">Redis-x64-3.2.100.zip</a></p><p>下载完成后将文件内容解压至C盘，文件夹重命名Reids(随便取，方便记就行)</p><p>打开CMD(建议管理员启动) 进入Redis目录 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cd C:&#x2F;Redis</span></pre></td></tr></table></figure><p>执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span></pre></td></tr></table></figure><p>如果打印出Redis的图案就说明安装是正确的</p><p><img alt="示例" data-src="https://tvax2.sinaimg.cn/large/006Et0gvgy1gamo8a71u2j30gj08mt94.jpg" class="lazyload"></p><p><code>Redis版本信息 端口号 进程ID 以及Redis的官方网址</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>接下来重新打开一个CMD窗口，注意刚才的窗口不要关闭</p><p>新窗口执行命令，进入Redis目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cd C:&#x2F;Redis</span></pre></td></tr></table></figure><p>在Redis目录下执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span></pre></td></tr></table></figure><p>就可以使用了</p><h2 id="Redis基础命令"><a href="#Redis基础命令" class="headerlink" title="Redis基础命令"></a>Redis基础命令</h2><p><strong>set 与 get</strong></p><p>set命令语法 ： set key value</p><p><code>注意：set命令的value值如果带有空格需要加上“”号 列如存入名字：kiven chen 时，不加“”会报错 ERR syntax error</code></p><p>get命令语法： get key</p><p>set示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">set username zhangsan</span></pre></td></tr></table></figure><p>回车 ， cmd打印OK 表示完成</p><p>get示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">get username</span></pre></td></tr></table></figure><p>回车 ， cmd会打印出“zhangsan”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;Windows上的Redis在github上有一个开源项目，但是好像很久没有维护更新了，上一次是在2016年。&lt;/p&gt;
&lt;p&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://best-maple.github.io/categories/Redis/"/>
    
      <category term="Window" scheme="http://best-maple.github.io/categories/Redis/Window/"/>
    
    
      <category term="Redis" scheme="http://best-maple.github.io/tags/Redis/"/>
    
      <category term="Window" scheme="http://best-maple.github.io/tags/Window/"/>
    
  </entry>
  
  <entry>
    <title>2020 ~ 新年快乐 ~ 😜</title>
    <link href="http://best-maple.github.io/2020/01/01/2020-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90-%F0%9F%98%9C/"/>
    <id>http://best-maple.github.io/2020/01/01/2020-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90-%F0%9F%98%9C/</id>
    <published>2020-01-01T04:14:11.000Z</published>
    <updated>2020-01-01T05:21:15.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你好，2020-请多多关照。"><a href="#你好，2020-请多多关照。" class="headerlink" title="你好，2020 ~ 请多多关照。"></a>你好，2020 ~ 请多多关照。</h1><p>​        转眼已是2020，回想2019，感觉自己有很多遗憾，做的并不够好</p><p>​        2月份从学校出来开始找工作，也不知道去哪儿~ 和同学一商量，就来到了成都，一直身在校园的我其实很少出省，上一次也是在好几年前去过上海，感觉城市与城市之间并没有什么不同，大相径庭。感受最多的其实还是地方文化差异，虽说都是中国，但各个地区有各个地区独有的地方。</p><p>​        在成都找工作投简历，大约一周时间，两家通过，但是对我们都还没毕业就赶鸭子上架的学生来讲，待遇也只是实习生的水平。不过还算能活下去，勉强待下。</p><p>​        进了公司，自然而然，公司需要你做什么你就得做什么，不可能按照自己的意愿去分配你的工作，于是我从原本偏向后端的程序员，虎头虎脑的去做Web，搭页面，测试数据干了大半年，出差去现场部署。到现在，感觉很奇怪~  前端不像前端后端不像后端，我已经不清楚自己的定位了。</p><p>​        毕竟也是2020了，准备整理整理自己，决定好一个方向，再努力，完善自己。</p><p>​                                                                                    </p><p>​                                                                                                                                                                                                                                        20200101结</p>]]></content>
    
    <summary type="html">
    
      2020 ~ 新篇章
    
    </summary>
    
    
      <category term="杂谈" scheme="http://best-maple.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://best-maple.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>SQL - row_number() over()</title>
    <link href="http://best-maple.github.io/2019/12/30/SQL%20-%20row_number()%20over()/"/>
    <id>http://best-maple.github.io/2019/12/30/SQL%20-%20row_number()%20over()/</id>
    <published>2019-12-30T03:21:21.000Z</published>
    <updated>2020-01-01T04:12:49.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>查询表中的数据，如果某一字段有重复则取最后一条或者第一条</p></blockquote><p>数据如下：</p><p>其中标注了三组含有重复值的字段（hphm）</p><img data-src="https://wx3.sinaimg.cn/mw690/006Et0gvgy1gaellv0bxoj316c0bugsb.jpg" class="lazyload"><p> 对其中hphm字段有重复的字段进行节选，取最后一条或第一天进行数据统计</p><blockquote><p>使用<code>row_number() over()</code>查询</p></blockquote><p>直接贴代码↓</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.*  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ( </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> *, row_number() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> hphm <span class="keyword">order</span> <span class="keyword">by</span> jylsh <span class="keyword">asc</span>) <span class="keyword">as</span> group_index </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">from</span> VehicleInfo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">) d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> d.group_index = <span class="number">1</span></span></pre></td></tr></table></figure><p>结果↓</p><p><img alt="查询结果" data-src="https://tvax3.sinaimg.cn/large/006Et0gvgy1gaelu2uj5tj316m02s400.jpg" class="lazyload"></p><blockquote><p>解析</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *, row_number() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> hphm <span class="keyword">order</span> <span class="keyword">by</span> jylsh <span class="keyword">asc</span>) <span class="keyword">as</span> group_index <span class="keyword">from</span> VehicleInfo</span></pre></td></tr></table></figure><p>这一条语句执行之后会产生如下数据↓ （此处为了方便查看节选部分字段）</p><p><img alt="查询结果" data-src="https://wx4.sinaimg.cn/mw690/006Et0gvgy1gaepuqrpamj30gq0cediw.jpg" class="lazyload"></p><p>为重复数据编上号，再将此结果集为目标进行查询，<code>where d.group_index = 1</code>即可得到重复数据的第一条数据，可以利用asc与desc来排序，得到最后一条或者第一条，SQL默认为Asc排序</p><blockquote><p><code>row_number() over()</code> 用法</p></blockquote><ul><li><p>语法   </p><pre><code>row_number() over(order by 排序列 asc )row_number() over(partition by 分组列 order by 排序列  asc)</code></pre></li></ul><ul><li><p>数据：<img alt="数据" data-src="https://tvax2.sinaimg.cn/large/006Et0gvgy1gaer2yoqgtj30he02bjrn.jpg" class="lazyload"></p></li><li><p>使用</p><ol><li><p>row_number() over(order by 排序列 asc )</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,row_number() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> TB_StudentInfo.S_ID) <span class="keyword">as</span> dataIndex </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">TB_StudentInfo <span class="keyword">inner</span> <span class="keyword">join</span> TB_GradeInfo </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">TB_GradeInfo.G_ID = TB_StudentInfo.S_Grade</span></pre></td></tr></table></figure><p> <img alt="查询结果" data-src="https://tva4.sinaimg.cn/large/006Et0gvgy1gaer8dblcuj30jb02d74k.jpg" class="lazyload"></p><p> 可以看到最末尾新增一列dataIndex，可以以此作为条件进行筛选</p></li><li><p>row_number() over(partition by 分组列 order by 排序列  asc)</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> TB_StudentInfo.S_Sex <span class="keyword">order</span> <span class="keyword">by</span> TB_StudentInfo.S_ID) <span class="keyword">as</span> dataIndex </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">TB_StudentInfo <span class="keyword">inner</span> <span class="keyword">join</span> TB_GradeInfo </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">TB_GradeInfo.G_ID = TB_StudentInfo.S_Grade</span></pre></td></tr></table></figure><p> <img alt="查询结果" data-src="https://tva1.sinaimg.cn/large/006Et0gvgy1gaerqxa6lnj30je02n74l.jpg" class="lazyload"></p><p> 以S_Sex进行分组排序   <code>partition by S_Sex</code></p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;查询表中的数据，如果某一字段有重复则取最后一条或者第一条&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据如下：&lt;/p&gt;
&lt;p&gt;其中标注了三组含有重复值的字段（hphm）&lt;/p&gt;
&lt;img data-src=&quot;https://wx3.sinaimg.
      
    
    </summary>
    
    
      <category term="编程" scheme="http://best-maple.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="SQL" scheme="http://best-maple.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>知乎问答【世界上什么最可怕】</title>
    <link href="http://best-maple.github.io/2019/12/05/%E7%9F%A5%E4%B9%8E%E6%96%87%E7%AB%A0%E3%80%90%E4%B8%96%E7%95%8C%E4%B8%8A%E4%BB%80%E4%B9%88%E6%9C%80%E5%8F%AF%E6%80%95%E3%80%91/"/>
    <id>http://best-maple.github.io/2019/12/05/%E7%9F%A5%E4%B9%8E%E6%96%87%E7%AB%A0%E3%80%90%E4%B8%96%E7%95%8C%E4%B8%8A%E4%BB%80%E4%B9%88%E6%9C%80%E5%8F%AF%E6%80%95%E3%80%91/</id>
    <published>2019-12-05T02:01:06.000Z</published>
    <updated>2019-12-05T05:10:27.594Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.zhihu.com/question/356188192" target="_blank" rel="noopener">世界上什么最可怕？-知乎</a></strong></p><p><img alt="无尽森林" data-src="https://tvax3.sinaimg.cn/mw690/006Et0gvgy1g9lmdffpq2j33y8280hdx.jpg" class="lazyload"></p><hr><p>今天早上我一好哥们儿微信给我发了一个链接</p><p>邀请回答知乎问题【世界上什么最可怕？】</p><p>我当时心想咱们现在年轻人能怕什么？就怕穷</p><p>于是在公交车上，我带着一丝好奇想看看别人的回答，点进了问答文章</p><blockquote><p><em>人言可畏、爱情、欲望、无知、蟑螂、死亡、浑浑噩噩的状态、没钱、年龄、误解、人性的恶，自我否定、失去希望、孤独、迷茫 … …</em></p></blockquote><p>在我漫不经心的翻阅一大片回答后</p><p>我认真的在想到底什么是世界上最可怕的</p><p>真的是穷吗？或者死亡？孤独？</p><p>想起曾看过的一部电影《 流浪猫鲍勃》</p><hr><p>主人公因小时候父母的关系问题，没有得到同年应有的关爱与亲情，导致他最后变成一个堕落的人，走上吸毒的深渊，家人抛弃了他，朋友也仅仅是毒友。<code>（简短描述，可能有偏差）</code></p><hr><p>上述经历，放在任何一个人身上，我相信没有人会觉得这没什么，这不可怕。</p><p>当然这部电影结局是好的，通过种种努力，他戒了毒，有了女朋友，家人也原谅了他，还出了书。</p><p>想起这些我发现，这些可怕的事情，是一个过程，他经历完了这些过程，并且生活趋于美好了~</p><p>我想，我能给出的答案是，如果一件事，没有尽头，那就是最可怕的</p><ul><li>无尽的流言蜚语</li><li>无尽的欲望</li><li>无尽的蟑螂</li><li>无尽的穷</li><li>无尽的孤独</li><li>无尽的迷茫</li></ul><p>终究会使人走向死亡，也就有了尽头。</p><blockquote><p><em><a href="https://www.zhihu.com/question/356188192/answer/923091364" target="_blank" rel="noopener">最后附上我的知乎回答-点击直达</a></em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.zhihu.com/question/356188192&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;世界上什么最可怕？-知乎&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;无尽森林
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://best-maple.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://best-maple.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="见闻" scheme="http://best-maple.github.io/tags/%E8%A7%81%E9%97%BB/"/>
    
  </entry>
  
  <entry>
    <title>开篇文章</title>
    <link href="http://best-maple.github.io/2019/12/04/%E5%BC%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://best-maple.github.io/2019/12/04/%E5%BC%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2019-12-04T02:59:23.000Z</published>
    <updated>2019-12-05T02:33:36.350Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hi~ Hexo&quot;);</span></pre></td></tr></table></figure><p><em>感觉现在个人Blog还挺流行的，交换交换友链之类的，感觉还挺有意思</em></p><p><em>于是花了两个小时，按照教程搭了一个</em></p><p><em>后期再调整调整，换个域名啥的</em></p><p><em>开篇也没什么想写的，目前就这样吧。</em></p><p><em>以后在这里写写东西，补充学习记录吧</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://best-maple.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂谈" scheme="http://best-maple.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="Hexo" scheme="http://best-maple.github.io/tags/Hexo/"/>
    
      <category term="随笔" scheme="http://best-maple.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
